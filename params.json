{"name":"Business-rules","tagline":"A JavaScript library for building out the logic and UI for business rules.","body":"[VIEW THE DEMO NOW](http://vnykmshr.github.io/business-rules/)\r\n\r\n# Business Rules for JavaScript\r\n\r\n\r\nWhen you're working in a business environment (especially an \"enterprisy\" environment),\r\nbusiness rules make the world go 'round. Business-level decision makers need to be able\r\nto alter application behavior and logic with minimal technical invasiveness.\r\n\r\nUsually, business rule engines come packaged as $100K Java installations and a gaggle\r\nof business consultants. Let's just call this a lighter-weight solution.\r\n\r\nThe goal of this library is to:\r\n\r\n1. Give JavaScript developers drop-in jQuery UI widgets for building business rule interfaces.\r\n2. Give developers a rule engine that can be ported to any server-side language for running business rules built with the UI tools.\r\n\r\n## Examples\r\n\r\nCheckout the examples directory if you just want to dive in, it demonstrates all the features\r\npretty well!\r\n\r\n## $.fn.conditionsBuilder()\r\n\r\nThe `$.fn.conditionsBuilder()` method has two forms, the first being:\r\n\r\n```javascript\r\n$(\"#myDiv\").conditionsBuilder({fields: [...], data: {...});\r\n```\r\n\r\nThe first form creates a `ConditionsBuilder` object for the given DOM element with the passed fields and data.\r\nThe `fields` param is an array of objects that define the factors that can be used in conditional statements.\r\nEach has a `label`, `name` and an array of `operators`. It may also have an `options` array of objects\r\nwith `label` and `name`.\r\n\r\nEach operator is an object with `label`, `name` and `fieldType`. The `fieldType` can be:\r\n\r\n* `\"none\"` - The operator does not require further data entry (ie `\"present\"`, `\"blank\"`).\r\n* `\"text\"` - User will be presented with an input of `type=text`.\r\n* `\"textarea\"` - User will be presented with a textarea.\r\n* `\"select\"` - User will be presented with a select dropdown populated with the parent field's `options` array.\r\n\r\nThe `data` param is an object that will be used to initially populate the UI (ie if business rules have already\r\nbeen created and the user wants to edit them). If the `data` option is not passed, the UI will be\r\ngenerated without any initial conditions.\r\n\r\nThe object passed as `data` should be a \"conditional object\", meaning it has a single key of `all` or `any`\r\nand a value of an array of nodes. These nodes can either be rule objects or nested conditional objects.\r\n\r\nA rule object has `name`, `operator` and `value` strings. The `name` should match a field's `name` property,\r\nthe `operator` should match an operator's `name` property, and the `value` is an arbitrary string value\r\nentered by the user in the UI.\r\n\r\nOnce the UI has been built by the `ConditionsBuilder` and the user has entered information, the data can\r\nbe retrieved by using the second form of the `conditionsBuilder` method:\r\n\r\n```javascript\r\nvar data = $(\"#myDiv\").conditionsBuilder(\"data\");\r\n```\r\n\r\nThis will serialize the entered conditionals into a data object. This object can be persisted and then later\r\nused to create a new `ConditionsBuilder` for editing. This data object will also be used to instantiate\r\na `BusinessRules.RuleEngine` object for running the conditional logic.\r\n\r\n\r\n## $.fn.actionsBuilder()\r\n\r\nThe `$.fn.actionsBuilder` has an identical API to `$.fn.conditionsBuilder`, but it uses a different data structure.\r\nThe `fields` property should be an array of action objects. Each action object has a `label` and `name`.\r\nAn action object may have a `fields` property that is an array of action objects, allowing for nested action data.\r\nAll action objects that are not \"top level\" should also have a `fieldType` of `text`, `textarea` or `select`.\r\n\r\nHere's an example of what a \"Send Email\" action could look like:\r\n\r\n```javascript\r\n$(\"#myDiv\").actionsBuilder({fields: [\r\n  {label: \"Send Email\", value: \"sendEmail\", fields: [\r\n    {label: \"To\", name: \"to\", fieldType: \"text\"},\r\n    {label: \"CC\", name: \"cc\", fieldType: \"text\"},\r\n    {label: \"BCC\", name: \"bcc\", fieldType: \"text\"},\r\n    {label: \"Subject\", name: \"subject\", fieldType: \"text\"},\r\n    {label: \"Body\", name: \"body\", fieldType: \"textarea\"}\r\n  ]}\r\n]});\r\n```\r\n\r\nAction objects with a `fieldType` of `select` should not have a `fields` property -- rather they have an `options`\r\nproperty with a `label` and `name` for each option. That option object, however, can have a `fields` property.\r\nThis allows you to specify nested fields that will only be displayed if the given option has been selected.\r\n\r\nBuilding on the last example, this allows the user to specify an email template, or use a custom Subject and Body:\r\n\r\n```javascript\r\n$(\"#myDiv\").actionsBuilder({fields: [\r\n  {label: \"Send Email\", value: \"sendEmail\", fields: [\r\n    {label: \"To\", name: \"to\", fieldType: \"text\"},\r\n    {label: \"CC\", name: \"cc\", fieldType: \"text\"},\r\n    {label: \"BCC\", name: \"bcc\", fieldType: \"text\"},\r\n    {label: \"Email Template\", name: \"template\", fieldType: \"select\", options: [\r\n      {label: \"Welcome Email\", name: \"welcomeEmail\"},\r\n      {label: \"Followup Email\", name: \"followupEmail\"},\r\n      {label: \"Custom Email\", name: \"customEmail\", fields: [\r\n        {label: \"Subject\", name: \"subject\", fieldType: \"text\"},\r\n        {label: \"Body\", name: \"body\", fieldType: \"textarea\"}\r\n      ]}\r\n    ]}\r\n  ]}\r\n]});\r\n```\r\n\r\nIn this example, the \"Subject\" and \"Body\" fields will only be displayed if the user has selected the \"Custom Email\"\r\ntemplate option.\r\n\r\nTo get the data out of the UI, run the `actionsBuilder` method with `\"data\"`:\r\n\r\n```javascript\r\nvar data = $(\"#myDiv\").actionsBuilder(\"data\");\r\n```\r\n\r\nEach action data object has a `name` that matches the corresponding field's `value`, and a `value` property with the\r\nuser-entered value. It may also have a `fields` array of nested action data objects, which correspond to the nested\r\nfield structure of the builder.\r\n\r\n## BusinessRules.RuleEngine\r\n\r\nWhile the `ConditionsBuilder` and `ActionsBuilder` give us a UI to build business rule configurations, we still need\r\nsomething to interpret the configuration, apply the logic and conditionally run the actions. This is where the\r\n`BusinessRules.RuleEngine` comes in.\r\n\r\nThe `RuleEngine` is initialized with a `conditions` object and an `actions` array, just as they would be when fetched\r\nfrom the UI using `conditionsBuilder(\"data\")` and `actionsBuilder(\"data\")`. This would be a common way of instantiating\r\na `RuleEngine`:\r\n\r\n```javascript\r\nvar engine = new BusinessRules.RuleEngine({\r\n  conditions: $(\"#myConditions\").conditionsBuilder(\"data\"),\r\n  actions: $(\"#myActions\").actionsBuilder(\"data\")\r\n});\r\n```\r\n\r\nOnce your engine has been instantiated, you can use the `#run` method to apply the conditional logic to a set of data,\r\nand then conditionally run the actions. Since the engine is only responsible for running logic and shouldn't have to\r\nbe aware of the actual data, you need to pass in an object that represents the context to run conditionals on,\r\nand another object with functions that map to the actions. For example:\r\n\r\n```javascript\r\nvar engine = new BusinessRules.RuleEngine({\r\n  conditions: {all: [{name: \"name\", operator: \"present\", value: \"\"}, {name: \"age\", operator: \"greaterThanEqual\", value: \"21\"}]},\r\n  actions: [{name: \"action-select\", value: \"giveDrink\", fields: [{name: \"drinkType\", value: \"martini\"}]}]\r\n});\r\n\r\nvar conditionsAdapter = {name: \"Joe\", age: 22};\r\nvar actionsAdapter = {giveDrink: function(data) { alert(\"Gave user a \" + data.find(\"drinkType\")); } };\r\n\r\nengine.run(conditionsAdapter, actionsAdapter);\r\n```\r\n\r\nValues used in the `conditionsAdapter` can be simple strings and numbers, but it can also be a function that will be lazily executed.\r\nFor example, this adapter would pull the name and age from fields on the page (a more likely scenario than hard coded values):\r\n\r\n```javascript\r\nvar conditionsAdapter = {\r\n  name: function() { $(\"#nameField\").val(); },\r\n  age: function() { $(\"#ageField\").val(); }\r\n};\r\n```\r\n\r\nIt is also possible to use *asynchronous* functions in your conditionsAdapter. To do so,\r\nhave your function accept a callback function and call it when you have your value.\r\n\r\n```javascript\r\nvar conditionsAdapter = {\r\n  logoVisible: function(done) {\r\n    // Cannot determine if logo is visible until DOM ready\r\n    $(function() {\r\n      var visible = $(\"#logo\").is(\":visible\");\r\n      done(visible);\r\n    });\r\n  }\r\n};\r\n```\r\n\r\nThe `BusinessRules.RuleEngine` object can be used in either the browser or in a server environment (ie Node.js). It could also\r\nbe ported to another language simply enough, or run inside a JavaScript runtime within Ruby, Java, etc.\r\n\r\n### Conditional Operators\r\n\r\nThe `RuleEngine` comes with the following standard operators that can be used inside conditionals:\r\n\r\n* present\r\n* blank\r\n* equalTo\r\n* notEqualTo\r\n* greaterThan\r\n* greaterThanEqual\r\n* lessThan\r\n* lessThanEqual\r\n* includes\r\n* matchesRegex\r\n\r\nCustom operators can be added to a `RuleEngine` using the `addOperators` method:\r\n\r\n```javascript\r\nvar engine = new BusinessRules.RuleEngine({\r\n  conditions: {all: [{name: \"password\", operator: \"longerThan\", value: \"6\"}]},\r\n  actions: []\r\n});\r\n\r\nengine.addOperators({\r\n  longerThan: function(actual, length) {\r\n    return actual.length > parseInt(length, 10);\r\n  }\r\n});\r\n```\r\n\r\nIt is also possible to create *asynchronous* operators if your logic cannot be run synchronously.\r\nTo do so, simply have your operator function accept a third callback param and call it when\r\nyou have your result:\r\n\r\n```javascript\r\nengine.addOperators({\r\n  delayedOperator: function(actual, target, done) {\r\n    setTimeout(function() { done(true); }, 1000);\r\n  }\r\n});\r\n```\r\n\r\nThe `addOperators` method also allows you to override the standard operators if, heaven forbid, you find that necessary.\r\n\r\n### Action Functions\r\n\r\nWhen a function on your `actionsAdapter` object is called, it is passed a `Finder` object. The `Finder` object has a\r\n`data` property that will return the action's data structure so that you can traverse it yourself. This data\r\nstructure can look something like:\r\n\r\n```javascript\r\n[{name: \"drinkType\", value: \"martini\", fields: [\r\n  {name: \"oliveCount\", value: \"3\"},\r\n  {name: \"shaken\", value: \"yes\"}\r\n]}]\r\n```\r\n\r\nWhile you certainly can traverse this structure, chances are you just want to quickly access the values. This is why\r\nthe `Finder` gives you the `find` convenience method, which takes one or more names and returns the matching value:\r\n\r\n```javascript\r\nvar actionsAdapter = {\r\n  giveDrink: function(data) {\r\n    var drinkType = data.find(\"drinkType\"),\r\n        oliveCount = data.find(\"drinkType\", \"oliveCount\"),\r\n        shaken = data.find(\"drinkType\", \"shaken\");\r\n    console.log(drinkType, oliveCount, shaken); // \"martini\", \"3\", \"yes\"\r\n  }\r\n};\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}